/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * Apelle
 * 
> A communist music queue

`apelle` is a service for handling a shared music queue. Users can insert songs
in the queues, and upvote them to push them upward. `apelle` will track the
position of each song in the queue, and the position of the currently playing
song.

It also fetch the song data from the sources (for now, only Youtube is
supported). Users provides only the minimal necessary to identify the song (e.g.
the youtube video ID).
        
 * OpenAPI spec version: 2.0.0-alpha
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';

export type Config = string | QueueConfigCreate;

export type CurrentAllOf = {
	song: IdOrRepSong;
};

export type Current = TimeRef & CurrentAllOf;

export type Cursor = string;

export type IdOrRepQueueConfigOneOfRoles = { [key: string]: QueueUserRole };

export type IdOrRepQueueConfigOneOf = {
	autolike: boolean;
	banned_role: string;
	created: string;
	creator_role: string;
	default_role: string;
	id: string;
	roles: IdOrRepQueueConfigOneOfRoles;
	updated: string;
};

/**
 * Either an id or a representation of a resource
 */
export type IdOrRepQueueConfig = string | IdOrRepQueueConfigOneOf;

/**
 * User that first added the song
 */
export type IdOrRepSongOneOfAddedBy = string | null;

/**
 * Additional data from the song source

These contains stuff like thumbnails,
the artist, an url or any source specific
data. They are provided on-demand
as they require querying the source service
 */
export type IdOrRepSongOneOfSourceDataAnyOf = { [key: string]: unknown };

/**
 * Additional data from the song source

These contains stuff like thumbnails,
the artist, an url or any source specific
data. They are provided on-demand
as they require querying the source service
 */
export type IdOrRepSongOneOfSourceData = IdOrRepSongOneOfSourceDataAnyOf | null;

export type IdOrRepSongOneOf = {
	/** User that first added the song */
	added_by?: IdOrRepSongOneOfAddedBy;
	/** When the song was added */
	created: string;
	/** Duration of the song */
	duration: string;
	/** Unique id of the song */
	id: string;
	/** Additional data from the song source

These contains stuff like thumbnails,
the artist, an url or any source specific
data. They are provided on-demand
as they require querying the source service */
	source_data?: IdOrRepSongOneOfSourceData;
	/** Title of the song */
	title: string;
};

/**
 * Either an id or a representation of a resource
 */
export type IdOrRepSong = string | IdOrRepSongOneOf;

/**
 * The total number of items
 * @minimum 0
 */
export type PageInfoCursorTotal = number | null;

/**
 * Information about a page
 */
export interface PageInfoCursor {
	first?: string;
	last?: string;
	next?: string;
	page: string;
	prev?: string;
	/**
	 * The size of the page
	 * @minimum 0
	 */
	size: number;
	/**
	 * The total number of items
	 * @minimum 0
	 */
	total?: PageInfoCursorTotal;
}

/**
 * The total number of items
 * @minimum 0
 */
export type PageInfoU32Total = number | null;

/**
 * Information about a page
 */
export interface PageInfoU32 {
	/** @minimum 0 */
	first?: number;
	/** @minimum 0 */
	last?: number;
	/** @minimum 0 */
	next?: number;
	/** @minimum 0 */
	page: number;
	/** @minimum 0 */
	prev?: number;
	/**
	 * The size of the page
	 * @minimum 0
	 */
	size: number;
	/**
	 * The total number of items
	 * @minimum 0
	 */
	total?: PageInfoU32Total;
}

/**
 * Data to pass the frontend describing the song
 */
export type PaginatedSearchResponseItemCursorItemsItemDetails = { [key: string]: unknown };

export type PaginatedSearchResponseItemCursorItemsItem = {
	/** Data to pass the frontend describing the song */
	details: PaginatedSearchResponseItemCursorItemsItemDetails;
	/** Source that provided this search result */
	source: string;
	/** Data to pass the service to resolve the song */
	state: SearchResponseItemStateValue;
};

/**
 * A page of results
 */
export interface PaginatedSearchResponseItemCursor {
	/** The items in the page */
	items: PaginatedSearchResponseItemCursorItemsItem[];
	/** Information about the page */
	page_info: PageInfoCursor;
}

/**
 * Information about a source registered in the database
 */
export type PaginatedSourceItemsItem = {
	created: string;
	last_heard: string;
	name: string;
	urn: string;
};

/**
 * A page of results
 */
export interface PaginatedSource {
	/** The items in the page */
	items: PaginatedSourceItemsItem[];
	/** Information about the page */
	page_info: PageInfoU32;
}

/**
 * Register himself as a provider
 */
export interface ProviderRegistration {
	/** Use fast handshake

This suggest to the `songs` service that the webhook is known to work
and that checks can be skipped */
	fast_handshake?: boolean;
	/** URN of the source this provider can answer for */
	source_urn: string;
	/** Url where this provider is serving the provider API */
	url: string;
}

export type QueueCurrent = null | Current;

export type QueueQueue = { [key: string]: QueuedSong };

export interface Queue {
	code: string;
	config: IdOrRepQueueConfig;
	created: string;
	current?: QueueCurrent;
	id: string;
	player_state_id: string;
	queue: QueueQueue;
	updated: string;
}

export type QueueConfigRoles = { [key: string]: QueueUserRole };

export interface QueueConfig {
	autolike: boolean;
	banned_role: string;
	created: string;
	creator_role: string;
	default_role: string;
	id: string;
	roles: QueueConfigRoles;
	updated: string;
}

export type QueueConfigCreateRoles = { [key: string]: QueueUserRoleCreate };

export interface QueueConfigCreate {
	autolike?: boolean;
	banned_role: string;
	creator_role: string;
	default_role: string;
	roles: QueueConfigCreateRoles;
}

export type QueueCreateCode = string | null;

export interface QueueCreate {
	code?: QueueCreateCode;
	config?: Config;
}

/**
 * An action a user makes on a queue
 */
export type QueueUserAction = (typeof QueueUserAction)[keyof typeof QueueUserAction];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QueueUserAction = {
	GET_QUEUE: 'GET_QUEUE',
	DELETE_QUEUE: 'DELETE_QUEUE',
	CONFIGURE_QUEUE: 'CONFIGURE_QUEUE',
	REMOVE_SONG: 'REMOVE_SONG',
	BAN_SONG: 'BAN_SONG',
	UNBAN_SONG: 'UNBAN_SONG',
	ENQUEUE_SONG: 'ENQUEUE_SONG',
	PLAY_SONG: 'PLAY_SONG',
	PAUSE_SONG: 'PAUSE_SONG',
	NEXT_SONG: 'NEXT_SONG',
	AUTO_NEXT_SONG: 'AUTO_NEXT_SONG',
	LIKE_SONG: 'LIKE_SONG',
	BAN_USER: 'BAN_USER',
	UNBAN_USER: 'UNBAN_USER',
	REMOVE_USER: 'REMOVE_USER'
} as const;

export interface QueueUserRole {
	can_grant: string[];
	can_revoke: string[];
	id: string;
	/** @minimum 0 */
	max_likes: number;
	permissions: QueueUserAction[];
}

export interface QueueUserRoleCreate {
	can_grant: string[];
	can_revoke: string[];
	/** @minimum 0 */
	max_likes: number;
	permissions: QueueUserAction[];
}

export interface QueuedSong {
	/**
	 * Number of likes this song has
	 * @minimum 0
	 */
	likes: number;
	/** When the song was queued */
	queued_at: string;
	/** Song that was queued */
	song: IdOrRepSong;
	/**
	 * Number of likes this song has by the current user
	 * @minimum 0
	 */
	user_likes: number;
}

/**
 * Data that the user used to define the song

e.g. the video id for youtube
 */
export type ResolveSongRequestData = { [key: string]: unknown };

export interface ResolveSongRequest {
	/** Data that the user used to define the song

e.g. the video id for youtube */
	data: ResolveSongRequestData;
	/** URN of the song source */
	source: string;
}

/**
 * Data to pass the frontend describing the song
 */
export type SearchResponseItemDetails = { [key: string]: unknown };

export interface SearchResponseItem {
	/** Data to pass the frontend describing the song */
	details: SearchResponseItemDetails;
	/** Source that provided this search result */
	source: string;
	/** Data to pass the service to resolve the song */
	state: SearchResponseItemStateValue;
}

export type SearchResponseItemStateOneOfData = { [key: string]: unknown };

export type SearchResponseItemStateOneOfState =
	(typeof SearchResponseItemStateOneOfState)[keyof typeof SearchResponseItemStateOneOfState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchResponseItemStateOneOfState = {
	New: 'New'
} as const;

/**
 * Need to be resolved
 */
export type SearchResponseItemStateOneOf = {
	data: SearchResponseItemStateOneOfData;
	state: SearchResponseItemStateOneOfState;
};

export type SearchResponseItemStateOneOfFourState =
	(typeof SearchResponseItemStateOneOfFourState)[keyof typeof SearchResponseItemStateOneOfFourState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchResponseItemStateOneOfFourState = {
	Known: 'Known'
} as const;

/**
 * Is a known song
 */
export type SearchResponseItemStateOneOfFour = {
	id: string;
	state: SearchResponseItemStateOneOfFourState;
};

/**
 * How to resolve this search item
 */
export type SearchResponseItemState =
	| SearchResponseItemStateOneOf
	| SearchResponseItemStateOneOfFour;

export type SearchResponseItemStateValueOneOfData = { [key: string]: unknown };

export type SearchResponseItemStateValueOneOfState =
	(typeof SearchResponseItemStateValueOneOfState)[keyof typeof SearchResponseItemStateValueOneOfState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchResponseItemStateValueOneOfState = {
	New: 'New'
} as const;

/**
 * Need to be resolved
 */
export type SearchResponseItemStateValueOneOf = {
	data: SearchResponseItemStateValueOneOfData;
	state: SearchResponseItemStateValueOneOfState;
};

export type SearchResponseItemStateValueOneOfFourState =
	(typeof SearchResponseItemStateValueOneOfFourState)[keyof typeof SearchResponseItemStateValueOneOfFourState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchResponseItemStateValueOneOfFourState = {
	Known: 'Known'
} as const;

/**
 * Is a known song
 */
export type SearchResponseItemStateValueOneOfFour = {
	id: string;
	state: SearchResponseItemStateValueOneOfFourState;
};

/**
 * How to resolve this search item
 */
export type SearchResponseItemStateValue =
	| SearchResponseItemStateValueOneOf
	| SearchResponseItemStateValueOneOfFour;

/**
 * User that first added the song
 */
export type SongAddedBy = string | null;

/**
 * Additional data from the song source

These contains stuff like thumbnails,
the artist, an url or any source specific
data. They are provided on-demand
as they require querying the source service
 */
export type SongSourceDataAnyOf = { [key: string]: unknown };

/**
 * Additional data from the song source

These contains stuff like thumbnails,
the artist, an url or any source specific
data. They are provided on-demand
as they require querying the source service
 */
export type SongSourceData = SongSourceDataAnyOf | null;

export interface Song {
	/** User that first added the song */
	added_by?: SongAddedBy;
	/** When the song was added */
	created: string;
	/** Duration of the song */
	duration: string;
	/** Unique id of the song */
	id: string;
	/** Additional data from the song source

These contains stuff like thumbnails,
the artist, an url or any source specific
data. They are provided on-demand
as they require querying the source service */
	source_data?: SongSourceData;
	/** Title of the song */
	title: string;
}

/**
 * Information about a source registered in the database
 */
export interface Source {
	created: string;
	last_heard: string;
	name: string;
	urn: string;
}

/**
 * Create a new source

This is sent from source providers to the songs service
to signal that a new source is available
 */
export interface SourceRegister {
	name: string;
	urn: string;
}

export type TimeRefOneOf = {
	position: string;
};

export type TimeRefOneOfTwo = {
	starts_at: string;
};

export type TimeRef = TimeRefOneOf | TimeRefOneOfTwo;

/**
 * Data to create a new user
 */
export interface UserCreateDto {
	/** Unique user name */
	name: string;
	/** Password */
	password: string;
}

/**
 * Data about a user
 */
export interface UserDto {
	/** When the user was created */
	created: string;
	/** Identifier of the user */
	id: string;
	/** When the user was last seen */
	last_login: string;
	/** Unique user name */
	name: string;
	/** Roles of the user */
	roles: string[];
	/** When the user was last updated */
	updated: string;
}

export type UserUpdateDtoName = string | null;

export type UserUpdateDtoPassword = string | null;

export interface UserUpdateDto {
	name?: UserUpdateDtoName;
	password?: UserUpdateDtoPassword;
}

export type QueuesCreateParams = {
	/**
 * Return the full queue config instead of just the UUID
Return the whole config instead of just the id
 */
	config?: boolean;
};

export type QueuesCreateBody = null | QueueCreate;

export type QueuesGetParams = {
	/**
	 * Return the full queue config instead of just the UUID
	 */
	config?: boolean;
	/**
	 * Return the full song data instead of just the UUID
	 */
	songs?: boolean;
	songs_source?: boolean;
};

export type QueuesEnqueueParams = {
	/**
	 * Override the default behavior of auto-liking
	 */
	autolike?: boolean | null;
	/**
	 * Return the full song data instead of just the UUID
	 */
	song?: boolean;
	/**
	 * Return also the source data for the song
	 */
	song_source?: boolean;
};

export type QueuesNextParams = {
	/**
 * Force this call to be evaluated in the `auto-next` mode

If missing, the call will pass in the `auto-next` mode only if the
conditions for one to succeed are met
 */
	auto?: boolean | null;
	/**
	 * Move to a particular song instead of the next in list
	 */
	song?: string | null;
};

export type SongsSearchParams = {
	/**
	 * Search query
	 */
	q: string;
	/**
 * List of sources to search

Empty to use all sources
 */
	source?: string[];
	/**
	 * Maximum number of items per page
	 * @minimum 0
	 */
	page_size?: number;
	/**
	 * Requested page
	 */
	page?: null | string;
};

export type SongsGetParams = {
	/**
	 * Include the data from the song source
	 */
	source_data?: boolean;
};

export type SongsListParams = {
	/**
	 * Maximum number of items per page
	 * @minimum 0
	 */
	page_size?: number;
	/**
	 * Requested page
	 */
	page?: null | number;
};

/**
 * Returns the api exposed by a specific service
 * @summary Service api docs
 */
export const apiDocsPublic = <TData = AxiosResponse<unknown>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api-docs/openapi.json`, options);
};

/**
 * Queue configs are immutable. When a queue change its config, a new config is
created instead of changing the old one. This makes the result of this call
cachable.
 * @summary Returns a queue config
 */
export const configsGet = <TData = AxiosResponse<QueueConfig>>(
	id: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/configs/queues/${id}`, options);
};

/**
 * Create a new empty queue with the given code and config.

If the config is not provided, a the default config will be used.
If no code is provided, a random code will be generated.
 * @summary Create a new queue
 */
export const queuesCreate = <TData = AxiosResponse<Queue>>(
	queuesCreateBody: QueuesCreateBody,
	params?: QueuesCreateParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/queues`, queuesCreateBody, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * @summary Read the queue data
 */
export const queuesGet = <TData = AxiosResponse<Queue>>(
	queueId: string,
	params?: QueuesGetParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/queues/${queueId}`, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * @summary Read the queue data
 */
export const queuesDelete = <TData = AxiosResponse<void>>(
	queueId: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/queues/${queueId}`, options);
};

/**
 * You can plug an object from the `/search` endpoint straight into this
endpoint. Additional fields will be ignored. If a `state: "New"` song is
given, it will be solved even if already solved somewhere else.

`song` and `song_source` will be reported to the songs service, and the
returned value will be expanded accordingly.

Trying to add a song that is already in the queue, or is the playing one
will result in a `409 Conflict`.
 * @summary Add a song to the queue
 */
export const queuesEnqueue = <TData = AxiosResponse<QueuedSong>>(
	queueId: string,
	searchResponseItem: SearchResponseItem,
	params?: QueuesEnqueueParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/queues/${queueId}/enqueue`, searchResponseItem, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * @summary Read the queue data
 */
export const queuesEvents = <TData = AxiosResponse<unknown>>(
	queueId: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/queues/${queueId}/events`, options);
};

/**
 * Changes the current song to another one, and set the new one as playing.

If no song is given, the one on top of the queue will be used. If the queue
is empty or the given song is not in the queue, a `404 Not Found` error will
be returned.

This endpoint can be accessed through two possible channels. Either one has
the `QUEUE_NEXT` permission, or the `QUEUE_AUTO_NEXT` permission. The second
channel requires additional restrictions to be met:
- The current song must be null, or ended without stopping.
- The song cannot be specified, enabling only moving to the top song.

If a song is not specified, the `If-Match` header is required.
 * @summary Change the current song
 */
export const queuesNext = <TData = AxiosResponse<void>>(
	queueId: string,
	params?: QueuesNextParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/queues/${queueId}/next`, undefined, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * @summary Read the queue data
 */
export const queuesLike = <TData = AxiosResponse<void>>(
	queueId: string,
	songId: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/queues/${queueId}/queue/${songId}/like`, undefined, options);
};

/**
 * Search for songs based on a query. The query will be normalized by
lowercasing it, removing all the non-alphanumeric characters, and
normalizing all spaces with a single space.

If songs from only one source is wanted, the `source` query parameter can be
used. It can be repeated to generate an aggregated query. If omitted, all
available sources will be used.

The order of the songs from a single source is kept. Different sources are
randomly mixed, but in a way that depends only from the set of sources
choosen and the query.

The songs are paginated. The cursor is an opaque string. The duration of
validity of the cursor depends on the specific providers. In case it
expires, a `400 Bad Request` is returned.
 * @summary Search for songs
 */
export const songsSearch = <TData = AxiosResponse<PaginatedSearchResponseItemCursor>>(
	params: SongsSearchParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/songs/search`, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * Get the data of a song that was previously resolved. If `source_data` is set
to `true`, the data from the song source will be included (like thumbnails
and url).
 * @summary Get song data
 */
export const songsGet = <TData = AxiosResponse<Song>>(
	id: string,
	params?: SongsGetParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/songs/solved/${id}`, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * Get a paginated list of sources. The sources are alphabetically ordered.
 * @summary List available sources
 */
export const songsList = <TData = AxiosResponse<PaginatedSource>>(
	params?: SongsListParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/songs/sources`, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * Create a new user with the given name and password. No global role is
assigned. Name must be unique, not empty, not containing trailing or leading
spaces and control characters. It must also fit in a http header.
 * @summary Create a new user
 */
export const usersCreate = <TData = AxiosResponse<UserDto>>(
	userCreateDto: UserCreateDto,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/users`, userCreateDto, options);
};

/**
 * Get data about the user the credentials used refer to.
 * @summary Current user data
 */
export const usersGet = <TData = AxiosResponse<UserDto>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/users/me`, options);
};

/**
 * Delete the user the credentials used refer to.
 * @summary Delete current user
 */
export const usersDelete = <TData = AxiosResponse<void>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/users/me`, options);
};

/**
 * Modify the datas about the user the credentials used refer to.

See the creation endpoint for the constraints.
 * @summary Patch current user data
 */
export const usersPatch = <TData = AxiosResponse<UserDto>>(
	userUpdateDto: UserUpdateDto,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.patch(`/api/users/me`, userUpdateDto, options);
};

export type ApiDocsPublicResult = AxiosResponse<unknown>;
export type ConfigsGetResult = AxiosResponse<QueueConfig>;
export type QueuesCreateResult = AxiosResponse<Queue>;
export type QueuesGetResult = AxiosResponse<Queue>;
export type QueuesDeleteResult = AxiosResponse<void>;
export type QueuesEnqueueResult = AxiosResponse<QueuedSong>;
export type QueuesEventsResult = AxiosResponse<unknown>;
export type QueuesNextResult = AxiosResponse<void>;
export type QueuesLikeResult = AxiosResponse<void>;
export type SongsSearchResult = AxiosResponse<PaginatedSearchResponseItemCursor>;
export type SongsGetResult = AxiosResponse<Song>;
export type SongsListResult = AxiosResponse<PaginatedSource>;
export type UsersCreateResult = AxiosResponse<UserDto>;
export type UsersGetResult = AxiosResponse<UserDto>;
export type UsersDeleteResult = AxiosResponse<void>;
export type UsersPatchResult = AxiosResponse<UserDto>;
