/**
 * Generated by orval v7.7.0 🍺
 * Do not edit manually.
 * Apelle API
 * > A communist music queue

`apelle` is a backend for handling a shared music queue. 
Users can insert songs in the queues, and upvote them to push them upward. `apelle`
will track the position of each song in the queue, and the position of the currently
playing song.

It also fetch the song data from the sources (for now, only Youtube is supported).
Users provides only the minimal necessary to identify the song (e.g. the youtube video ID).
 * OpenAPI spec version: 0.0.1
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';

export type ApelleUserRole = (typeof ApelleUserRole)[keyof typeof ApelleUserRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApelleUserRole = {
	ADMIN: 'ADMIN',
	USER: 'USER'
} as const;

/**
 * The song currently being played
 */
export interface CurrentSongQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
	/** Duration of the song */
	duration: Duration;
	/** Source of the song */
	kind: SongKind;
	/** Eventual public url of the song */
	url?: string;
	/** Available thumbnails for the song */
	thumbnails?: ThumbnailQueryDto[];
	/** If the song is currently stopped */
	stopped: boolean;
	/** Moment at which the song should have started to reach the current position */
	starts_at: Instant;
	/** Current position in the song */
	position: Duration;
}

export type CurrentSongStateEventDtoKind =
	(typeof CurrentSongStateEventDtoKind)[keyof typeof CurrentSongStateEventDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CurrentSongStateEventDtoKind = {
	'current-song-state': 'current-song-state'
} as const;

/**
 * An authoritative broadcast of the current song state.

After receiving this message a client must assume the current song is in the provided state.
 */
export interface CurrentSongStateEventDto {
	kind: CurrentSongStateEventDtoKind;
	current?: CurrentSongQueryDto;
	/** If present, contains the new value of the player state ID */
	player_state_id?: Uuid;
}

export type Duration = string;

export type Instant = string;

/**
 * Paged response for Apelle API
 */
export interface Page {
	items: unknown[];
	page_info: PageInfo;
}

/**
 * Number of items in the search, if available
 * @minimum 0
 */
export type PageInfoTotalItems = number | null;

/**
 * Next page token
 */
export type PageInfoNext = string | null;

/**
 * Previous page token
 */
export type PageInfoPrev = string | null;

/**
 * Info about a page of responses
 */
export interface PageInfo {
	/**
	 * Number of items in the search, if available
	 * @minimum 0
	 */
	total_items?: PageInfoTotalItems;
	/**
	 * Number of items in the page
	 * @minimum 0
	 */
	items: number;
	/**
	 * Page number
	 * @minimum 0
	 */
	number: number;
	/** Next page token */
	next?: PageInfoNext;
	/** Previous page token */
	prev?: PageInfoPrev;
}

/**
 * Paged response for Apelle API
 */
export interface PageSearchedSongQueryDto {
	items: SearchedSongQueryDto[];
	page_info: PageInfo;
}

export type QueueDeleteEventDtoKind =
	(typeof QueueDeleteEventDtoKind)[keyof typeof QueueDeleteEventDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QueueDeleteEventDtoKind = {
	'queue-delete': 'queue-delete'
} as const;

/**
 * Signal that the queue was deleted.

This message also signal the closure of the event stream.
 */
export interface QueueDeleteEventDto {
	kind: QueueDeleteEventDtoKind;
}

/**
 * A message from the server.

The `kind` property discriminates between the different messages.
 */
export type QueueEventDto =
	| QueueStateEventDto
	| QueueDeleteEventDto
	| CurrentSongStateEventDto
	| QueuedSongsStateEventDto
	| QueuedSongDeleteEventDto;

/**
 * A queue of songs
 */
export interface QueueQueryDto {
	/** Unique ID of the queue */
	id: Uuid;
	/** Unique code of the queue */
	code: string;
	/** The current playing song, if any */
	current?: CurrentSongQueryDto;
	/** The songs in the queue */
	queue: QueuedSongShortQueryDto[];
	/** Id of the current state of the player

This is an opaque id that is regenerated at each modification of the playing
song. Requests can be conditional on the state they refer to, so they are
refused in case of a mismatch. */
	player_state_id: Uuid;
}

export type QueueStateEventDtoKind =
	(typeof QueueStateEventDtoKind)[keyof typeof QueueStateEventDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QueueStateEventDtoKind = {
	'queue-state': 'queue-state'
} as const;

/**
 * An authoritative broadcast of the queue state.

After receiving this message a client must assume the queue is in the provided state.
 */
export interface QueueStateEventDto {
	kind: QueueStateEventDtoKind;
	queue: QueueQueryDto;
}

/**
 * Data about a user of a queue
 */
export interface QueueUserQueryDto {
	/** Unique ID of the user */
	id: Uuid;
	/** Unique username of the user */
	name: string;
	/** Comma separated list of roles the user has */
	roles: ApelleUserRole[];
	/** Role of the user in the queue. Fetch the actual permissions from `/queues/roles/{id}` */
	queue_role: Uuid;
	/** Number of likes given in the queue */
	likes: number;
	/** Maximum number of likes that can be given */
	max_likes: number;
}

export interface QueueUserRolePermissionsQueryDto {
	queue: QueueUserRoleQueuePermissionsQueryDto;
	queue_users: QueueUserRoleQueueUsersPermissionsQueryDto;
	delete: boolean;
}

export interface QueueUserRoleQueryDto {
	readonly id: Uuid;
	name: string;
	max_likes: number;
	permissions: QueueUserRolePermissionsQueryDto;
}

export interface QueueUserRoleQueuePermissionsQueryDto {
	start: boolean;
	stop: boolean;
	next: boolean;
	like: boolean;
	enqueue: boolean;
	remove: boolean;
	ban: boolean;
}

export interface QueueUserRoleQueueUsersPermissionsQueryDto {
	grant_roles: string[];
	remove_roles: string[];
	ban: boolean;
	remove: boolean;
}

export type QueuedSongDeleteEventDtoKind =
	(typeof QueuedSongDeleteEventDtoKind)[keyof typeof QueuedSongDeleteEventDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QueuedSongDeleteEventDtoKind = {
	'queued-song-delete': 'queued-song-delete'
} as const;

/**
 * Signal the removal of a single song.

Nothing else is changed. The song should be removed mantaining the order of the others.
 */
export interface QueuedSongDeleteEventDto {
	kind: QueuedSongDeleteEventDtoKind;
	/** The song to delete */
	deleted_id: Uuid;
}

/**
 * Full description of a song inside a queue
 */
export interface QueuedSongQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
	/** Duration of the song */
	duration: Duration;
	/** Source of the song */
	kind: SongKind;
	/** Eventual public url of the song */
	url?: string;
	/** Available thumbnails for the song */
	thumbnails?: ThumbnailQueryDto[];
	/** The moment this song was added to the queue */
	queued_at: Instant;
	/** The number of likes this song received */
	likes: number;
	/** The number of likes this song received by this user */
	user_likes: number;
}

/**
 * A song inside a queue
 */
export interface QueuedSongShortQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
	/** The moment this song was added to the queue */
	queued_at: Instant;
	/** The number of likes this song received */
	likes: number;
	/** The number of likes this song received by this user */
	user_likes: number;
}

export type QueuedSongsStateEventDtoKind =
	(typeof QueuedSongsStateEventDtoKind)[keyof typeof QueuedSongsStateEventDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QueuedSongsStateEventDtoKind = {
	'queued-songs-state': 'queued-songs-state'
} as const;

/**
 * An authoritative broadcast of the queued songs state.

After receiving this message a client must assume the queued songs are in the provided state.
 */
export interface QueuedSongsStateEventDto {
	kind: QueuedSongsStateEventDtoKind;
	/** The songs in the queue */
	queue: QueuedSongShortQueryDto[];
}

/**
 * A song searched from a probider
 */
export interface SearchedSongQueryDto {
	/** Name of the song */
	name: string;
	/** Data to send to the `/enqueue` endpoint to add this song */
	enqueue_data: SongAddDto;
	/** Eventual public url of the song */
	url?: string;
	/** Available thumbnails for the song */
	thumbnails?: ThumbnailQueryDto[];
}

/**
 * Data defining a song to add
 */
export type SongAddDto = YoutubeSongAddDto;

export type SongKind = (typeof SongKind)[keyof typeof SongKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SongKind = {
	Youtube: 'Youtube'
} as const;

/**
 * A song
 */
export interface SongQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
	/** Duration of the song */
	duration: Duration;
	/** Source of the song */
	kind: SongKind;
	/** Eventual public url of the song */
	url?: string;
	/** Available thumbnails for the song */
	thumbnails?: ThumbnailQueryDto[];
}

/**
 * Basic data about a song
 */
export interface SongShortQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
}

/**
 * A thumbnail for a song
 */
export interface ThumbnailQueryDto {
	/** The thumbnail width */
	width: number;
	/** The thumbnail height */
	height: number;
	/** The public URL where the thumbnail can be found */
	url: string;
}

/**
 * @pattern [a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}
 */
export type Uuid = string;

/**
 * User creation data
 */
export interface UserCreateDto {
	/** Unique username for the user */
	name: string;
	/** Password for the user */
	password: string;
}

/**
 * Data about a single user
 */
export interface UserQueryDto {
	/** Unique ID of the user */
	id: Uuid;
	/** Unique username of the user */
	name: string;
	/** Comma separated list of roles the user has */
	roles: ApelleUserRole[];
}

export type YoutubeSongAddDtoKind =
	(typeof YoutubeSongAddDtoKind)[keyof typeof YoutubeSongAddDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const YoutubeSongAddDtoKind = {
	Youtube: 'Youtube'
} as const;

/**
 * A song that comes from youtube
 */
export interface YoutubeSongAddDto {
	kind: YoutubeSongAddDtoKind;
	/** The video ID */
	video_id: string;
}

export type PostApiV1QueuesCQueueCodeQueueSongIdLikesParams = {
	/**
	 * How many time to like the song. If negative, nothing will happen.
	 */
	count?: number;
};

export type PostApiV1QueuesIQueueIdQueueSongIdLikesParams = {
	/**
	 * How many time to like the song. If negative, nothing will happen.
	 */
	count?: number;
};

export type GetApiV1SearchParams = {
	/**
	 * Page token. Must be obtained from a previous call to `/search`
	 */
	page?: string;
	/**
	 * Size of the requested page
	 */
	page_size?: number;
	/**
	 * Searched song query
	 */
	q: string;
};

/**
 * Create a new queue without any song inside it
 * @summary Create a new queue
 */
export const postApiV1Queues = <TData = AxiosResponse<QueueQueryDto>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues`, undefined, options);
};

/**
 * Get the queue state, with both the currently playing song and the list of songs to play next
 * @summary Get the queue state
 */
export const getApiV1QueuesCQueueCode = <TData = AxiosResponse<QueueQueryDto>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}`, options);
};

/**
 * Delete the queue permanently
 * @summary Delete the queue
 */
export const deleteApiV1QueuesCQueueCode = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}`, options);
};

/**
 * @summary Obtain a stream of events regarding this queue.
 */
export const getApiV1QueuesCQueueCodeEvents = <TData = AxiosResponse<QueueEventDto[]>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/events`, options);
};

/**
 * Start the next song in the queue.
The current one will be requeued as the last one, with no likes.
 * @summary Start playing the next song
 */
export const postApiV1QueuesCQueueCodeNext = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/next`, undefined, options);
};

/**
 * Add a song to the queue, with no likes.
 * @summary Add a song to the queue
 */
export const postApiV1QueuesCQueueCodeQueue = <TData = AxiosResponse<QueuedSongShortQueryDto>>(
	queueCode: string,
	songAddDto: SongAddDto,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/queue`, songAddDto, options);
};

/**
 * Get the full state of the queued song, with all data.
 * @summary Get the queued song
 */
export const getApiV1QueuesCQueueCodeQueueSongId = <TData = AxiosResponse<QueuedSongQueryDto>>(
	queueCode: string,
	songId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/queue/${songId}`, options);
};

/**
 * Remove the song from the queue.

TODO: ban functionality.
 * @summary Remove this song from the queue
 */
export const deleteApiV1QueuesCQueueCodeQueueSongId = <TData = AxiosResponse<void>>(
	queueCode: string,
	songId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}/queue/${songId}`, options);
};

/**
 * Add a like to the song, pushing it upwards in the queue.

If the maximum number of likes was already reached, the oldest like will be removed.
This will happen trasparently even if a number of likes larger than available is specified,
effectively removing all likes and moving them to the song.
 * @summary Add a like to the song
 */
export const postApiV1QueuesCQueueCodeQueueSongIdLikes = <TData = AxiosResponse<void>>(
	queueCode: string,
	songId: Uuid,
	params?: PostApiV1QueuesCQueueCodeQueueSongIdLikesParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/queue/${songId}/likes`, undefined, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * Play this song, ignoring the order of the queue.
 * @summary Play this song
 */
export const postApiV1QueuesCQueueCodeQueueSongIdPlay = <TData = AxiosResponse<void>>(
	queueCode: string,
	songId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/queue/${songId}/play`, undefined, options);
};

/**
 * Start playing music from the queue.
 * @summary Start playing
 */
export const postApiV1QueuesCQueueCodeStart = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/start`, undefined, options);
};

/**
 * Stop playing music from the queue.
 * @summary Stop playing
 */
export const postApiV1QueuesCQueueCodeStop = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/stop`, undefined, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesCQueueCodeUsersIUserId = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueCode: string,
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/users/i/${userId}`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesCQueueCodeUsersIUserId = <TData = AxiosResponse<void>>(
	queueCode: string,
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}/users/i/${userId}`, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesCQueueCodeUsersMe = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/users/me`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesCQueueCodeUsersMe = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}/users/me`, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesCQueueCodeUsersNUserName = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueCode: string,
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/users/n/${userName}`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesCQueueCodeUsersNUserName = <TData = AxiosResponse<void>>(
	queueCode: string,
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}/users/n/${userName}`, options);
};

/**
 * Get the queue state, with both the currently playing song and the list of songs to play next
 * @summary Get the queue state
 */
export const getApiV1QueuesIQueueId = <TData = AxiosResponse<QueueQueryDto>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}`, options);
};

/**
 * Delete the queue permanently
 * @summary Delete the queue
 */
export const deleteApiV1QueuesIQueueId = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}`, options);
};

/**
 * @summary Obtain a stream of events regarding this queue.
 */
export const getApiV1QueuesIQueueIdEvents = <TData = AxiosResponse<QueueEventDto[]>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/events`, options);
};

/**
 * Start the next song in the queue.
The current one will be requeued as the last one, with no likes.
 * @summary Start playing the next song
 */
export const postApiV1QueuesIQueueIdNext = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/next`, undefined, options);
};

/**
 * Add a song to the queue, with no likes.
 * @summary Add a song to the queue
 */
export const postApiV1QueuesIQueueIdQueue = <TData = AxiosResponse<QueuedSongShortQueryDto>>(
	queueId: Uuid,
	songAddDto: SongAddDto,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/queue`, songAddDto, options);
};

/**
 * Get the full state of the queued song, with all data.
 * @summary Get the queued song
 */
export const getApiV1QueuesIQueueIdQueueSongId = <TData = AxiosResponse<QueuedSongQueryDto>>(
	queueId: Uuid,
	songId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/queue/${songId}`, options);
};

/**
 * Remove the song from the queue.

TODO: ban functionality.
 * @summary Remove this song from the queue
 */
export const deleteApiV1QueuesIQueueIdQueueSongId = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	songId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}/queue/${songId}`, options);
};

/**
 * Add a like to the song, pushing it upwards in the queue.

If the maximum number of likes was already reached, the oldest like will be removed.
This will happen trasparently even if a number of likes larger than available is specified,
effectively removing all likes and moving them to the song.
 * @summary Add a like to the song
 */
export const postApiV1QueuesIQueueIdQueueSongIdLikes = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	songId: Uuid,
	params?: PostApiV1QueuesIQueueIdQueueSongIdLikesParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/queue/${songId}/likes`, undefined, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * Play this song, ignoring the order of the queue.
 * @summary Play this song
 */
export const postApiV1QueuesIQueueIdQueueSongIdPlay = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	songId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/queue/${songId}/play`, undefined, options);
};

/**
 * Start playing music from the queue.
 * @summary Start playing
 */
export const postApiV1QueuesIQueueIdStart = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/start`, undefined, options);
};

/**
 * Stop playing music from the queue.
 * @summary Stop playing
 */
export const postApiV1QueuesIQueueIdStop = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/stop`, undefined, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesIQueueIdUsersIUserId = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueId: Uuid,
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/users/i/${userId}`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesIQueueIdUsersIUserId = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}/users/i/${userId}`, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesIQueueIdUsersMe = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/users/me`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesIQueueIdUsersMe = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}/users/me`, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesIQueueIdUsersNUserName = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueId: Uuid,
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/users/n/${userName}`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesIQueueIdUsersNUserName = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}/users/n/${userName}`, options);
};

/**
 * Obtain details about a queue role, with permissions and maximum number of likes
 * @summary Get a queue role
 */
export const getApiV1QueuesRolesId = <TData = AxiosResponse<QueueUserRoleQueryDto>>(
	id: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/roles/${id}`, options);
};

/**
 * Search all available sources for a given song.

The returned values are sorted by relevance. Each one contains the DTO one should send to the `/enqueue`
endpoint to add the corresponding song.
 * @summary Search a song
 */
export const getApiV1Search = <TData = AxiosResponse<PageSearchedSongQueryDto>>(
	params: GetApiV1SearchParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/search`, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * Create an user that can access queues and vote on them
 * @summary Create a user
 */
export const postApiV1Users = <TData = AxiosResponse<UserQueryDto>>(
	userCreateDto: UserCreateDto,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/users`, userCreateDto, options);
};

/**
 * Returns the data of the user
 * @summary The user data
 */
export const getApiV1UsersIUserId = <TData = AxiosResponse<UserQueryDto>>(
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/users/i/${userId}`, options);
};

/**
 * Delete the user
 * @summary Delete user
 */
export const deleteApiV1UsersIUserId = <TData = AxiosResponse<void>>(
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/users/i/${userId}`, options);
};

/**
 * Returns the data of the user
 * @summary The user data
 */
export const getApiV1UsersMe = <TData = AxiosResponse<UserQueryDto>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/users/me`, options);
};

/**
 * Delete the user
 * @summary Delete user
 */
export const deleteApiV1UsersMe = <TData = AxiosResponse<void>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/users/me`, options);
};

/**
 * Returns the data of the user
 * @summary The user data
 */
export const getApiV1UsersNUserName = <TData = AxiosResponse<UserQueryDto>>(
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/users/n/${userName}`, options);
};

/**
 * Delete the user
 * @summary Delete user
 */
export const deleteApiV1UsersNUserName = <TData = AxiosResponse<void>>(
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/users/n/${userName}`, options);
};

/**
 * Return the version of the server
 * @summary Version of the server
 */
export const getApiV1Version = <TData = AxiosResponse<string>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/version`, options);
};

export type PostApiV1QueuesResult = AxiosResponse<QueueQueryDto>;
export type GetApiV1QueuesCQueueCodeResult = AxiosResponse<QueueQueryDto>;
export type DeleteApiV1QueuesCQueueCodeResult = AxiosResponse<void>;
export type GetApiV1QueuesCQueueCodeEventsResult = AxiosResponse<QueueEventDto[]>;
export type PostApiV1QueuesCQueueCodeNextResult = AxiosResponse<void>;
export type PostApiV1QueuesCQueueCodeQueueResult = AxiosResponse<QueuedSongShortQueryDto>;
export type GetApiV1QueuesCQueueCodeQueueSongIdResult = AxiosResponse<QueuedSongQueryDto>;
export type DeleteApiV1QueuesCQueueCodeQueueSongIdResult = AxiosResponse<void>;
export type PostApiV1QueuesCQueueCodeQueueSongIdLikesResult = AxiosResponse<void>;
export type PostApiV1QueuesCQueueCodeQueueSongIdPlayResult = AxiosResponse<void>;
export type PostApiV1QueuesCQueueCodeStartResult = AxiosResponse<void>;
export type PostApiV1QueuesCQueueCodeStopResult = AxiosResponse<void>;
export type GetApiV1QueuesCQueueCodeUsersIUserIdResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesCQueueCodeUsersIUserIdResult = AxiosResponse<void>;
export type GetApiV1QueuesCQueueCodeUsersMeResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesCQueueCodeUsersMeResult = AxiosResponse<void>;
export type GetApiV1QueuesCQueueCodeUsersNUserNameResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesCQueueCodeUsersNUserNameResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdResult = AxiosResponse<QueueQueryDto>;
export type DeleteApiV1QueuesIQueueIdResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdEventsResult = AxiosResponse<QueueEventDto[]>;
export type PostApiV1QueuesIQueueIdNextResult = AxiosResponse<void>;
export type PostApiV1QueuesIQueueIdQueueResult = AxiosResponse<QueuedSongShortQueryDto>;
export type GetApiV1QueuesIQueueIdQueueSongIdResult = AxiosResponse<QueuedSongQueryDto>;
export type DeleteApiV1QueuesIQueueIdQueueSongIdResult = AxiosResponse<void>;
export type PostApiV1QueuesIQueueIdQueueSongIdLikesResult = AxiosResponse<void>;
export type PostApiV1QueuesIQueueIdQueueSongIdPlayResult = AxiosResponse<void>;
export type PostApiV1QueuesIQueueIdStartResult = AxiosResponse<void>;
export type PostApiV1QueuesIQueueIdStopResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdUsersIUserIdResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesIQueueIdUsersIUserIdResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdUsersMeResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesIQueueIdUsersMeResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdUsersNUserNameResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesIQueueIdUsersNUserNameResult = AxiosResponse<void>;
export type GetApiV1QueuesRolesIdResult = AxiosResponse<QueueUserRoleQueryDto>;
export type GetApiV1SearchResult = AxiosResponse<PageSearchedSongQueryDto>;
export type PostApiV1UsersResult = AxiosResponse<UserQueryDto>;
export type GetApiV1UsersIUserIdResult = AxiosResponse<UserQueryDto>;
export type DeleteApiV1UsersIUserIdResult = AxiosResponse<void>;
export type GetApiV1UsersMeResult = AxiosResponse<UserQueryDto>;
export type DeleteApiV1UsersMeResult = AxiosResponse<void>;
export type GetApiV1UsersNUserNameResult = AxiosResponse<UserQueryDto>;
export type DeleteApiV1UsersNUserNameResult = AxiosResponse<void>;
export type GetApiV1VersionResult = AxiosResponse<string>;
