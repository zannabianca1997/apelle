/**
 * Generated by orval v7.7.0 ðŸº
 * Do not edit manually.
 * Apelle API (development)
 * > A communist music queue

`apelle` is a backend for handling a shared music queue. 
Users can insert songs in the queues, and upvote them to push them upward. `apelle`
will track the position of each song in the queue, and the position of the currently
playing song.

It also fetch the song data from the sources (for now, only Youtube is supported).
Users provides only the minimal necessary to identify the song (e.g. the youtube video ID).
 * OpenAPI spec version: 0.0.1
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';

export type ApelleUserRole = (typeof ApelleUserRole)[keyof typeof ApelleUserRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApelleUserRole = {
	ADMIN: 'ADMIN',
	USER: 'USER'
} as const;

/**
 * The song currently being played
 */
export interface CurrentSongQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
	/** Duration of the song */
	duration: Duration;
	/** Source of the song */
	kind: SongKind;
	/** Eventual public url of the song */
	url?: string;
	/** Available thumbnails for the song */
	thumbnails?: ThumbnailQueryDto[];
	/** If the song is currently stopped */
	stopped: boolean;
	/** Moment at which the song should have started to reach the current position */
	starts_at: Instant;
	/** Current position in the song */
	position: Duration;
}

export type Duration = string;

export type Instant = string;

export interface Permissions {
	queue: Queue;
	queueUsers: QueueUsers;
	delete: boolean;
}

export interface Queue {
	start: boolean;
	stop: boolean;
	next: boolean;
	like: boolean;
	enqueue: boolean;
	remove: boolean;
	ban: boolean;
}

export type QueueDeleteEventDtoKind =
	(typeof QueueDeleteEventDtoKind)[keyof typeof QueueDeleteEventDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QueueDeleteEventDtoKind = {
	'queue-delete': 'queue-delete'
} as const;

/**
 * Signal that the queue was deleted.

This message also signal the closure of the event stream.
 */
export interface QueueDeleteEventDto {
	kind: QueueDeleteEventDtoKind;
}

/**
 * A message from the server.

The `kind` property discriminates between the different messages.
 */
export type QueueEventDto = QueueStateEventDto | QueueDeleteEventDto;

/**
 * A queue of songs
 */
export interface QueueQueryDto {
	/** Unique ID of the queue */
	id: Uuid;
	/** Unique code of the queue */
	code: string;
	/** The current playing song, if any */
	current?: CurrentSongQueryDto;
	/** The songs in the queue */
	queue: QueuedSongShortQueryDto[];
}

export type QueueStateEventDtoKind =
	(typeof QueueStateEventDtoKind)[keyof typeof QueueStateEventDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QueueStateEventDtoKind = {
	'queue-state': 'queue-state'
} as const;

/**
 * An authoritative broadcast of the queue state.

After receiving this message a client must assume the queue is in the provided state.
 */
export interface QueueStateEventDto {
	kind: QueueStateEventDtoKind;
	queue: QueueQueryDto;
}

/**
 * Data about a user of a queue
 */
export interface QueueUserQueryDto {
	/** Unique ID of the user */
	id: Uuid;
	/** Unique username of the user */
	name: string;
	/** Comma separated list of roles the user has */
	roles: ApelleUserRole[];
	/** Role of the user in the queue */
	queue_role: string;
	/** Number of likes given in the queue */
	likes: number;
	/** Maximum number of likes that can be given */
	max_likes: number;
}

export interface QueueUserRole {
	name: string;
	maxLikes: number;
	permissions: Permissions;
}

export interface QueueUserRolesConfig {
	default: string;
	creator: string;
	banned: string;
	roles: string[];
}

export type QueueUsersGrantRoles = string[] | null;

export type QueueUsersRemoveRoles = string[] | null;

export interface QueueUsers {
	grantRoles: QueueUsersGrantRoles;
	removeRoles: QueueUsersRemoveRoles;
	remove: boolean;
	ban: boolean;
}

/**
 * Full description of a song inside a queue
 */
export interface QueuedSongQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
	/** Duration of the song */
	duration: Duration;
	/** Source of the song */
	kind: SongKind;
	/** Eventual public url of the song */
	url?: string;
	/** Available thumbnails for the song */
	thumbnails?: ThumbnailQueryDto[];
	/** The moment this song was added to the queue */
	queued_at: Instant;
	/** The number of likes this song received */
	likes: number;
	/** The number of likes this song received by this user */
	user_likes: number;
}

/**
 * A song inside a queue
 */
export interface QueuedSongShortQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
	/** The moment this song was added to the queue */
	queued_at: Instant;
	/** The number of likes this song received */
	likes: number;
}

/**
 * Data defining a song to add
 */
export type SongAddDto = YoutubeSongAddDto;

export type SongKind = (typeof SongKind)[keyof typeof SongKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SongKind = {
	Youtube: 'Youtube'
} as const;

/**
 * A song
 */
export interface SongQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
	/** Duration of the song */
	duration: Duration;
	/** Source of the song */
	kind: SongKind;
	/** Eventual public url of the song */
	url?: string;
	/** Available thumbnails for the song */
	thumbnails?: ThumbnailQueryDto[];
}

/**
 * Basic data about a song
 */
export interface SongShortQueryDto {
	/** Unique id of the song */
	id: Uuid;
	/** Name of the song */
	name: string;
}

/**
 * A thumbnail for a song
 */
export interface ThumbnailQueryDto {
	/** The thumbnail width */
	width: number;
	/** The thumbnail height */
	height: number;
	/** The public URL where the thumbnail can be found */
	url: string;
}

/**
 * @pattern [a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}
 */
export type Uuid = string;

/**
 * User creation data
 */
export interface UserCreateDto {
	/** Unique username for the user */
	name: string;
	/** Password for the user */
	password: string;
}

/**
 * Data about a single user
 */
export interface UserQueryDto {
	/** Unique ID of the user */
	id: Uuid;
	/** Unique username of the user */
	name: string;
	/** Comma separated list of roles the user has */
	roles: ApelleUserRole[];
}

export type YoutubeSongAddDtoKind =
	(typeof YoutubeSongAddDtoKind)[keyof typeof YoutubeSongAddDtoKind];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const YoutubeSongAddDtoKind = {
	Youtube: 'Youtube'
} as const;

/**
 * A song that comes from youtube
 */
export interface YoutubeSongAddDto {
	kind: YoutubeSongAddDtoKind;
	/** The video ID */
	video_id: string;
}

export type PostApiV1QueuesCQueueCodeQueueSongIdLikesParams = {
	/**
	 * How many time to like the song. If negative, nothing will happen.
	 */
	count?: number;
};

export type PostApiV1QueuesIQueueIdQueueSongIdLikesParams = {
	/**
	 * How many time to like the song. If negative, nothing will happen.
	 */
	count?: number;
};

/**
 * The list of all roles and the default ones.
 * @summary Get the list of roles and the default ones
 */
export const getApiV1ConfigsQueueUserRoles = <TData = AxiosResponse<QueueUserRolesConfig>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/configs/queue-user/roles`, options);
};

/**
 * The extended configuration for a role.
 * @summary Get the configuration for a role
 */
export const getApiV1ConfigsQueueUserRolesRoleName = <TData = AxiosResponse<QueueUserRole>>(
	roleName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/configs/queue-user/roles/${roleName}`, options);
};

/**
 * Create a new queue without any song inside it
 * @summary Create a new queue
 */
export const postApiV1Queues = <TData = AxiosResponse<QueueQueryDto>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues`, undefined, options);
};

/**
 * Get the queue state, with both the currently playing song and the list of songs to play next
 * @summary Get the queue state
 */
export const getApiV1QueuesCQueueCode = <TData = AxiosResponse<QueueQueryDto>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}`, options);
};

/**
 * Delete the queue permanently
 * @summary Delete the queue
 */
export const deleteApiV1QueuesCQueueCode = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}`, options);
};

/**
 * @summary Obtain a stream of events regarding this queue.
 */
export const getApiV1QueuesCQueueCodeEvents = <TData = AxiosResponse<QueueEventDto[]>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/events`, options);
};

/**
 * Start the next song in the queue.
The current one will be requeued as the last one, with no likes.
 * @summary Start playing the next song
 */
export const postApiV1QueuesCQueueCodeNext = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/next`, undefined, options);
};

/**
 * Add a song to the queue, with no likes.
 * @summary Add a song to the queue
 */
export const postApiV1QueuesCQueueCodeQueue = <TData = AxiosResponse<QueuedSongShortQueryDto>>(
	queueCode: string,
	songAddDto: SongAddDto,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/queue`, songAddDto, options);
};

/**
 * Get the full state of the queued song, with all data.
 * @summary Get the queued song
 */
export const getApiV1QueuesCQueueCodeQueueSongId = <TData = AxiosResponse<QueuedSongQueryDto>>(
	queueCode: string,
	songId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/queue/${songId}`, options);
};

/**
 * Add a like to the song, pushing it upwards in the queue.

If the maximum number of likes was already reached, the oldest like will be removed.
This will happen trasparently even if a number of likes larger than available is specified,
effectively removing all likes and moving them to the song.
 * @summary Add a like to the song
 */
export const postApiV1QueuesCQueueCodeQueueSongIdLikes = <TData = AxiosResponse<void>>(
	queueCode: string,
	songId: Uuid,
	params?: PostApiV1QueuesCQueueCodeQueueSongIdLikesParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/queue/${songId}/likes`, undefined, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * Start playing music from the queue.
 * @summary Start playing
 */
export const postApiV1QueuesCQueueCodeStart = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/start`, undefined, options);
};

/**
 * Stop playing music from the queue.
 * @summary Stop playing
 */
export const postApiV1QueuesCQueueCodeStop = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/c/${queueCode}/stop`, undefined, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesCQueueCodeUsersIUserId = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueCode: string,
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/users/i/${userId}`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesCQueueCodeUsersIUserId = <TData = AxiosResponse<void>>(
	queueCode: string,
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}/users/i/${userId}`, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesCQueueCodeUsersMe = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/users/me`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesCQueueCodeUsersMe = <TData = AxiosResponse<void>>(
	queueCode: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}/users/me`, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesCQueueCodeUsersNUserName = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueCode: string,
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/c/${queueCode}/users/n/${userName}`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesCQueueCodeUsersNUserName = <TData = AxiosResponse<void>>(
	queueCode: string,
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/c/${queueCode}/users/n/${userName}`, options);
};

/**
 * Get the queue state, with both the currently playing song and the list of songs to play next
 * @summary Get the queue state
 */
export const getApiV1QueuesIQueueId = <TData = AxiosResponse<QueueQueryDto>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}`, options);
};

/**
 * Delete the queue permanently
 * @summary Delete the queue
 */
export const deleteApiV1QueuesIQueueId = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}`, options);
};

/**
 * @summary Obtain a stream of events regarding this queue.
 */
export const getApiV1QueuesIQueueIdEvents = <TData = AxiosResponse<QueueEventDto[]>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/events`, options);
};

/**
 * Start the next song in the queue.
The current one will be requeued as the last one, with no likes.
 * @summary Start playing the next song
 */
export const postApiV1QueuesIQueueIdNext = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/next`, undefined, options);
};

/**
 * Add a song to the queue, with no likes.
 * @summary Add a song to the queue
 */
export const postApiV1QueuesIQueueIdQueue = <TData = AxiosResponse<QueuedSongShortQueryDto>>(
	queueId: Uuid,
	songAddDto: SongAddDto,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/queue`, songAddDto, options);
};

/**
 * Get the full state of the queued song, with all data.
 * @summary Get the queued song
 */
export const getApiV1QueuesIQueueIdQueueSongId = <TData = AxiosResponse<QueuedSongQueryDto>>(
	queueId: Uuid,
	songId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/queue/${songId}`, options);
};

/**
 * Add a like to the song, pushing it upwards in the queue.

If the maximum number of likes was already reached, the oldest like will be removed.
This will happen trasparently even if a number of likes larger than available is specified,
effectively removing all likes and moving them to the song.
 * @summary Add a like to the song
 */
export const postApiV1QueuesIQueueIdQueueSongIdLikes = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	songId: Uuid,
	params?: PostApiV1QueuesIQueueIdQueueSongIdLikesParams,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/queue/${songId}/likes`, undefined, {
		...options,
		params: { ...params, ...options?.params }
	});
};

/**
 * Start playing music from the queue.
 * @summary Start playing
 */
export const postApiV1QueuesIQueueIdStart = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/start`, undefined, options);
};

/**
 * Stop playing music from the queue.
 * @summary Stop playing
 */
export const postApiV1QueuesIQueueIdStop = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/queues/i/${queueId}/stop`, undefined, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesIQueueIdUsersIUserId = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueId: Uuid,
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/users/i/${userId}`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesIQueueIdUsersIUserId = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}/users/i/${userId}`, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesIQueueIdUsersMe = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/users/me`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesIQueueIdUsersMe = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}/users/me`, options);
};

/**
 * Returns the data of the queue user
 * @summary The queue user data
 */
export const getApiV1QueuesIQueueIdUsersNUserName = <TData = AxiosResponse<QueueUserQueryDto>>(
	queueId: Uuid,
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/queues/i/${queueId}/users/n/${userName}`, options);
};

/**
 * Remove the user from the queue. This will also remove all likes he has given.
 * @summary Remove the user from the queue
 */
export const deleteApiV1QueuesIQueueIdUsersNUserName = <TData = AxiosResponse<void>>(
	queueId: Uuid,
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/queues/i/${queueId}/users/n/${userName}`, options);
};

/**
 * Create an user that can access queues and vote on them
 * @summary Create a user
 */
export const postApiV1Users = <TData = AxiosResponse<UserQueryDto>>(
	userCreateDto: UserCreateDto,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.post(`/api/v1/users`, userCreateDto, options);
};

/**
 * Returns the data of the user
 * @summary The user data
 */
export const getApiV1UsersIUserId = <TData = AxiosResponse<UserQueryDto>>(
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/users/i/${userId}`, options);
};

/**
 * Delete the user
 * @summary Delete user
 */
export const deleteApiV1UsersIUserId = <TData = AxiosResponse<void>>(
	userId: Uuid,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/users/i/${userId}`, options);
};

/**
 * Returns the data of the user
 * @summary The user data
 */
export const getApiV1UsersMe = <TData = AxiosResponse<UserQueryDto>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/users/me`, options);
};

/**
 * Delete the user
 * @summary Delete user
 */
export const deleteApiV1UsersMe = <TData = AxiosResponse<void>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/users/me`, options);
};

/**
 * Returns the data of the user
 * @summary The user data
 */
export const getApiV1UsersNUserName = <TData = AxiosResponse<UserQueryDto>>(
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/users/n/${userName}`, options);
};

/**
 * Delete the user
 * @summary Delete user
 */
export const deleteApiV1UsersNUserName = <TData = AxiosResponse<void>>(
	userName: string,
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.delete(`/api/v1/users/n/${userName}`, options);
};

/**
 * Return the version of the server
 * @summary Version of the server
 */
export const getApiV1Version = <TData = AxiosResponse<string>>(
	options?: AxiosRequestConfig
): Promise<TData> => {
	return axios.get(`/api/v1/version`, options);
};

export type GetApiV1ConfigsQueueUserRolesResult = AxiosResponse<QueueUserRolesConfig>;
export type GetApiV1ConfigsQueueUserRolesRoleNameResult = AxiosResponse<QueueUserRole>;
export type PostApiV1QueuesResult = AxiosResponse<QueueQueryDto>;
export type GetApiV1QueuesCQueueCodeResult = AxiosResponse<QueueQueryDto>;
export type DeleteApiV1QueuesCQueueCodeResult = AxiosResponse<void>;
export type GetApiV1QueuesCQueueCodeEventsResult = AxiosResponse<QueueEventDto[]>;
export type PostApiV1QueuesCQueueCodeNextResult = AxiosResponse<void>;
export type PostApiV1QueuesCQueueCodeQueueResult = AxiosResponse<QueuedSongShortQueryDto>;
export type GetApiV1QueuesCQueueCodeQueueSongIdResult = AxiosResponse<QueuedSongQueryDto>;
export type PostApiV1QueuesCQueueCodeQueueSongIdLikesResult = AxiosResponse<void>;
export type PostApiV1QueuesCQueueCodeStartResult = AxiosResponse<void>;
export type PostApiV1QueuesCQueueCodeStopResult = AxiosResponse<void>;
export type GetApiV1QueuesCQueueCodeUsersIUserIdResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesCQueueCodeUsersIUserIdResult = AxiosResponse<void>;
export type GetApiV1QueuesCQueueCodeUsersMeResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesCQueueCodeUsersMeResult = AxiosResponse<void>;
export type GetApiV1QueuesCQueueCodeUsersNUserNameResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesCQueueCodeUsersNUserNameResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdResult = AxiosResponse<QueueQueryDto>;
export type DeleteApiV1QueuesIQueueIdResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdEventsResult = AxiosResponse<QueueEventDto[]>;
export type PostApiV1QueuesIQueueIdNextResult = AxiosResponse<void>;
export type PostApiV1QueuesIQueueIdQueueResult = AxiosResponse<QueuedSongShortQueryDto>;
export type GetApiV1QueuesIQueueIdQueueSongIdResult = AxiosResponse<QueuedSongQueryDto>;
export type PostApiV1QueuesIQueueIdQueueSongIdLikesResult = AxiosResponse<void>;
export type PostApiV1QueuesIQueueIdStartResult = AxiosResponse<void>;
export type PostApiV1QueuesIQueueIdStopResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdUsersIUserIdResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesIQueueIdUsersIUserIdResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdUsersMeResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesIQueueIdUsersMeResult = AxiosResponse<void>;
export type GetApiV1QueuesIQueueIdUsersNUserNameResult = AxiosResponse<QueueUserQueryDto>;
export type DeleteApiV1QueuesIQueueIdUsersNUserNameResult = AxiosResponse<void>;
export type PostApiV1UsersResult = AxiosResponse<UserQueryDto>;
export type GetApiV1UsersIUserIdResult = AxiosResponse<UserQueryDto>;
export type DeleteApiV1UsersIUserIdResult = AxiosResponse<void>;
export type GetApiV1UsersMeResult = AxiosResponse<UserQueryDto>;
export type DeleteApiV1UsersMeResult = AxiosResponse<void>;
export type GetApiV1UsersNUserNameResult = AxiosResponse<UserQueryDto>;
export type DeleteApiV1UsersNUserNameResult = AxiosResponse<void>;
export type GetApiV1VersionResult = AxiosResponse<string>;
